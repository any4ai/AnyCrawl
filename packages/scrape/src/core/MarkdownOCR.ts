export const OCR_BLOCK_OPEN = "[ANYCRAWL_OCR_TEXT]";
export const OCR_BLOCK_CLOSE = "[/ANYCRAWL_OCR_TEXT]";

export interface MarkdownImageOccurrence {
    imageStart: number;
    imageEnd: number;
    insertAfter: number;
    imageUrl: string;
}

interface BalancedContent {
    end: number;
    content: string;
}

interface ParsedImageToken {
    end: number;
    imageUrl: string;
}

function isWhitespace(char: string | undefined): boolean {
    return char !== undefined && /\s/.test(char);
}

function skipWhitespace(text: string, index: number): number {
    let cursor = index;
    while (cursor < text.length && isWhitespace(text[cursor])) {
        cursor += 1;
    }
    return cursor;
}

function parseBalancedContent(
    text: string,
    start: number,
    openChar: string,
    closeChar: string
): BalancedContent | null {
    if (text[start] !== openChar) {
        return null;
    }

    let depth = 1;
    let cursor = start + 1;

    while (cursor < text.length) {
        const char = text[cursor];

        if (char === "\\") {
            cursor += 2;
            continue;
        }

        if (char === openChar) {
            depth += 1;
            cursor += 1;
            continue;
        }

        if (char === closeChar) {
            depth -= 1;
            cursor += 1;
            if (depth === 0) {
                return {
                    end: cursor,
                    content: text.slice(start + 1, cursor - 1),
                };
            }
            continue;
        }

        cursor += 1;
    }

    return null;
}

function extractImageUrlFromDestination(destination: string): string {
    const trimmed = destination.trim();
    if (!trimmed) return "";

    if (trimmed.startsWith("<")) {
        const end = trimmed.indexOf(">");
        if (end > 1) {
            return trimmed.slice(1, end).trim();
        }
    }

    let cursor = 0;
    while (cursor < trimmed.length) {
        const char = trimmed[cursor];

        if (char === "\\") {
            cursor += 2;
            continue;
        }

        if (isWhitespace(char)) {
            break;
        }

        cursor += 1;
    }

    return trimmed.slice(0, cursor);
}

function parseImageTokenAt(text: string, imageStart: number): ParsedImageToken | null {
    if (text[imageStart] !== "!" || text[imageStart + 1] !== "[") {
        return null;
    }

    const altPart = parseBalancedContent(text, imageStart + 1, "[", "]");
    if (!altPart) {
        return null;
    }

    const parenStart = skipWhitespace(text, altPart.end);
    if (text[parenStart] !== "(") {
        return null;
    }

    const destinationPart = parseBalancedContent(text, parenStart, "(", ")");
    if (!destinationPart) {
        return null;
    }

    return {
        end: destinationPart.end,
        imageUrl: extractImageUrlFromDestination(destinationPart.content),
    };
}

function parseLinkedImageWrapperEnd(
    text: string,
    imageStart: number,
    imageEnd: number
): number | null {
    const wrapperStart = imageStart - 1;
    if (wrapperStart < 0 || text[wrapperStart] !== "[") {
        return null;
    }

    const wrapperBracket = parseBalancedContent(text, wrapperStart, "[", "]");
    if (!wrapperBracket) {
        return null;
    }

    // For linked images generated by markdown conversion:
    // [![alt](image-url)](link-url)
    if (wrapperBracket.end !== imageEnd + 1) {
        return null;
    }

    const outerParenStart = skipWhitespace(text, wrapperBracket.end);
    if (text[outerParenStart] !== "(") {
        return null;
    }

    const outerDestination = parseBalancedContent(text, outerParenStart, "(", ")");
    if (!outerDestination) {
        return null;
    }

    return outerDestination.end;
}

export function collectMarkdownImageOccurrences(markdown: string): MarkdownImageOccurrence[] {
    const occurrences: MarkdownImageOccurrence[] = [];
    let cursor = 0;

    while (cursor < markdown.length) {
        if (markdown[cursor] !== "!" || markdown[cursor + 1] !== "[") {
            cursor += 1;
            continue;
        }

        const parsedImage = parseImageTokenAt(markdown, cursor);
        if (!parsedImage) {
            cursor += 1;
            continue;
        }

        const linkedWrapperEnd = parseLinkedImageWrapperEnd(markdown, cursor, parsedImage.end);
        const insertAfter = linkedWrapperEnd ?? parsedImage.end;

        occurrences.push({
            imageStart: cursor,
            imageEnd: parsedImage.end,
            insertAfter,
            imageUrl: parsedImage.imageUrl,
        });

        cursor = insertAfter;
    }

    return occurrences;
}

export function normalizeOCRText(text: string): string {
    const stripped = text
        .replace(/\r/g, "")
        .replace(/\[\/?ANYCRAWL_OCR_TEXT\]/g, "")
        .replace(/\n{3,}/g, "\n\n")
        .trim();

    const maxLength = 4000;
    if (stripped.length <= maxLength) {
        return stripped;
    }

    return `${stripped.slice(0, maxLength)}...`;
}

function buildOCRBlock(text: string): string {
    const normalized = normalizeOCRText(text);
    return `\n\n${OCR_BLOCK_OPEN}\n${normalized}\n${OCR_BLOCK_CLOSE}\n`;
}

export function injectOCRBlocksAfterImages(
    markdown: string,
    occurrences: MarkdownImageOccurrence[],
    ocrTextByImageUrl: Map<string, string>
): string {
    if (occurrences.length === 0) {
        return markdown;
    }

    let cursor = 0;
    let output = "";

    for (const occurrence of occurrences) {
        const ocrText = ocrTextByImageUrl.get(occurrence.imageUrl) ?? "";
        output += markdown.slice(cursor, occurrence.insertAfter);
        output += buildOCRBlock(ocrText);
        cursor = occurrence.insertAfter;
    }

    output += markdown.slice(cursor);
    return output;
}
